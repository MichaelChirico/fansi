% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/substr2.R
\name{substr_ctl}
\alias{substr_ctl}
\alias{substr2_ctl}
\title{Control Sequence Aware Version of substr}
\usage{
substr_ctl(
  x,
  start,
  stop,
  warn = getOption("fansi.warn"),
  term.cap = getOption("fansi.term.cap"),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)

substr2_ctl(
  x,
  start,
  stop,
  type = "chars",
  round = "start",
  tabs.as.spaces = getOption("fansi.tabs.as.spaces"),
  tab.stops = getOption("fansi.tab.stops"),
  warn = getOption("fansi.warn"),
  term.cap = getOption("fansi.term.cap"),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)
}
\arguments{
\item{x}{a character vector or object that can be coerced to such.}

\item{start}{integer.  The first element to be replaced.}

\item{stop}{integer.  The last element to be replaced.}

\item{warn}{TRUE (default) or FALSE, whether to warn when potentially
problematic \emph{Control Sequences} are encountered.  These could cause the
assumptions \code{fansi} makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see \code{\link[=fansi]{?fansi}}).
If the problematic sequence is a tab, you can use the \code{tabs.as.spaces}
parameter on functions that have it, or the \code{tabs_as_spaces} function, to
turn the tabs to spaces and resolve the warning that way.}

\item{term.cap}{character a vector of the capabilities of the terminal, can
be any combination of "bright" (SGR codes 90-97, 100-107), "256" (SGR codes
starting with "38;5" or "48;5"), and "truecolor" (SGR codes starting with
"38;2" or "48;2"). Changing this parameter changes how \code{fansi}
interprets escape sequences, so you should ensure that it matches your
terminal capabilities. See \code{\link{term_cap_test}} for details.}

\item{ctl}{character, which \emph{Control Sequences} should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC-anchored URLs, \code{fansi}
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a \emph{Control Sequence} is treated specially with the \code{ctl}
parameter.
\itemize{
\item "nl": newlines.
\item "c0": all other "C0" control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
\item "sgr": ANSI CSI SGR sequences.
\item "csi": all non-SGR ANSI CSI sequences.
\item "url": OSC-anchored URLs
\item "osc": all non-OSC-anchored URL OSC sequences.
\item "esc": all other escape sequences.
\item "all": all of the above, except when used in combination with any of the
above, in which case it means "all but".
}}

\item{normalize}{TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. "\033[31;42m" becomes
"\033[31m\033[42m"), but will work better with code that assumes each SGR
code will be in its own escape as \code{crayon} does.}

\item{carry}{TRUE, FALSE, or a scalar string, controls whether active SGR
present at the end of an input vector element is carried into the next
vector element.  If FALSE each vector element is interpreted as if there
were no active state when they begin.  If character, then the active
state at the end of the \code{carry} string is carried into the first element of
\code{x}.  See the "State Interactions" section of \code{\link[=fansi]{?fansi}} for
details.}

\item{terminate}{TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  See the "State Interactions" section of \code{\link[=fansi]{?fansi}}
for details.}

\item{type}{character(1L) partial matching \code{c("chars", "width")}, although
\code{type="width"} only works correctly with R >= 3.2.2.  See
\code{\link[base:nchar]{?nchar}}. With "width", the results might be affected by
locale changes, Unicode database updates, and logic changes for processing
of complex graphemes.  Generally you should not rely on a specific output
e.g. by embedding it in unit tests.  For the most part \code{fansi} (currently)
uses the internals of \code{base::nchar(type='width')}, but there are exceptions
and this may change in the future.}

\item{round}{character(1L) partial matching
\code{c("start", "stop", "both", "neither")}, controls how to resolve
ambiguities when a \code{start} or \code{stop} value in "width" \code{type} mode falls
within a wide display character.  See details.}

\item{tabs.as.spaces}{FALSE (default) or TRUE, whether to convert tabs to
spaces.  This can only be set to TRUE if \code{strip.spaces} is FALSE.}

\item{tab.stops}{integer(1:n) indicating position of tab stops to use
when converting tabs to spaces.  If there are more tabs in a line than
defined tab stops the last tab stop is re-used.  For the purposes of
applying tab stops, each input line is considered a line and the character
count begins from the beginning of the input line.}
}
\value{
a character vector of the same length and with the same attributes as
x (after possible coercion and re-encoding to UTF-8).
}
\description{
\code{substr_ctl} is a drop-in replacement for \code{substr}.  Performance is
slightly slower than \code{substr}.  CSI SGR sequences will be included in the
substrings to reflect the format of the substring when it was embedded in
the source string.  Additionally, other \emph{Control Sequences} specified in
\code{ctl} are treated as zero-width.
}
\details{
\code{substr2_ctl} adds the ability to retrieve substrings based on display width
in addition to the normal character width.  \code{substr2_ctl} also provides the
option to convert tabs to spaces with \code{\link{tabs_as_spaces}} prior to taking
substrings.

Because exact substrings on anything other than character width cannot be
guaranteed (e.g. as a result of multi-byte encodings, or double display-width
characters) \code{substr2_ctl} must make assumptions on how to resolve provided
\code{start}/\code{stop} values that are infeasible and does so via the \code{round}
parameter.

If we use "start" as the \code{round} value, then any time the \code{start}
value corresponds to the middle of a multi-byte or a wide character, then
that character is included in the substring, while any similar partially
included character via the \code{stop} is left out.  The converse is true if we
use "stop" as the \code{round} value.  "neither" would cause all partial
characters to be dropped irrespective whether they correspond to \code{start} or
\code{stop}, and "both" could cause all of them to be included.

These functions map string lengths accounting for CSI SGR sequence semantics
to the naive length calculations, and then use the mapping in conjunction
with \code{\link[base:substr]{base::substr()}} to extract the string.  This concept is borrowed
directly from Gábor Csárdi's \code{crayon} package, although the implementation of
the calculation is different.
}
\note{
Non-ASCII strings are converted to and returned in UTF-8 encoding.
Width calculations will not work properly in R < 3.2.2.

If \code{stop} < \code{start}, the return value is always an empty string.
}
\examples{
substr_ctl("\033[42mhello\033[m world", 1, 9)
substr_ctl("\033[42mhello\033[m world", 3, 9)

## Width 2 and 3 are in the middle of an ideogram as
## start and stop positions respectively, so we control
## what we get with `round`
cn.string <- paste0("\033[42m", "\u4E00\u4E01\u4E03", "\033[m")
substr2_ctl(cn.string, 2, 3, type='width')
substr2_ctl(cn.string, 2, 3, type='width', round='both')
substr2_ctl(cn.string, 2, 3, type='width', round='start')
substr2_ctl(cn.string, 2, 3, type='width', round='stop')

## We can specify which escapes are considered special:
substr_ctl("\033[31mhello\tworld", 1, 6, ctl='sgr')
substr_ctl("\033[31mhello\tworld", 1, 6, ctl=c('all', 'c0'))

## `carry` allows SGR to carry from one element to the next
substr_ctl(c("\033[33mhello", "world"), 1, 3)
substr_ctl(c("\033[33mhello", "world"), 1, 3, carry=TRUE)
substr_ctl(c("\033[33mhello", "world"), 1, 3, carry="\033[44m")

## We can omit the termination
bleed <- substr_ctl(c("\033[41hello", "world"), 1, 3, terminate=FALSE)
\dontrun{writeLines(bleed)} # Style will bleed out of string
writeLines("\033[m")        # Stop bleeding if needed
}
\seealso{
\code{\link[=fansi]{?fansi}} for details on how \emph{Control Sequences} are
interpreted, particularly if you are getting unexpected results,
\code{\link{normalize_state}} for more details on what the \code{normalize} parameter does,
\code{\link{state_at_end}} to compute active state at the end of strings,
\code{\link{close_state}} to compute the sequence required to close active state.
}
