% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fansi-package.R
\docType{package}
\name{fansi}
\alias{fansi}
\alias{fansi-package}
\title{ANSI Control Sequence Aware String Functions}
\description{
Counterparts to R string manipulation functions that preserve ANSI
CSI SGR control sequences and treat them along with other control characters
and sequences as zero display-width.
}
\section{Control Characters and Sequences}{


Control characters and sequences are non-printing inline characters that can
be used to modify terminal display and behavior, for example by changing text
color or cursor position.  There are three types of control characters and
sequences that \code{fansi} treats specially:
\itemize{
\item "C0" control characters, such as tabs and carriage returns (we include
delete in this set, even though technically it is not part of it).
\item Sequences starting in "ESC[", also known as ANSI CSI sequences.
\item Sequences starting in "ESC" and followed by something other than "[".
}

All of these are considered zero display width for purposes of string width
calculations.

Escape sequences starting with ESC are assumed to be two characters
long (including the ESC) unless they are of the CSI variety, in which case
their length is computed as per the ANSI CSI spec.  There are non-CSI escape
sequences that may be longer than two characters, but \code{fansi} will treat them
as if they were two characters long.

In theory it is possible to encode ANSI CSI escape sequences with single byte
introducing character in the 0x40-0x5F range instead of the traditional
"ESC[".  Since this is rare and it conflicts with UTF-8 encoding, we do
not support it.
}

\section{ANSI CSI SGR Control Sequences}{


ANSI CSI SGR control sequences are the subset of CSI sequences that can be
used to change text appearance (e.g. color).  These sequences begin with
"ESC[" and end in "m".  \code{fansi} interprets these sequences and writes new
ones to the output strings in such a way that the original formatting is
preserved.  In most cases this should be transparent to the user.

Occasionally there may be mismatches between how \code{fansi} and a display
interpret the CSI SGR sequences, which may produce display artifacts.  The
most likely source of artifacts are control characters or sequences that move
the cursor or change the display, or CSI SGR sequences \code{fansi} does not
interpret such as:
\itemize{
\item Unknown SGR substrings.
\item "C0" control characters like tabs and carriage returns.
\item Other escape sequences.
}

Another possible source of problems is that different displays parse
and interpret control sequences differently.  The common sequences that
you are likely to encounter in CSI SGR formatted text tend to be treated
consistently, but less common ones are not.  \code{fansi} tries to hew by the
ECMA-48 specification \strong{for CSI control sequences}, but not all terminals
do.

The most likely source of problems will be 24-bit CSI SGR sequences.
For example, a 24-bit color sequences such as "ESC[38;2;31;42;4" is a
single foreground color to a terminal that supports it, or separate
foreground, background, faint, and underline specifications for one that does
not.  To mitigate this particular problem you tell \code{fansi} what your terminal
capabilities are via the \code{term.cap} parameter or the "fansi.term.cap" global
option, although \code{fansi} does try to detect them by default.

\code{fansi} will will warn if it encounters control sequences or characters
that it cannot interpret or that might conflict with terminal capabilities.
You can turn off warnings via the \code{warn} parameter or via the "fansi.warn"
global option.

You can also #'
\code{fansi} can work around "C0" tab control characters by turning them into
spaces first with \link{tabs_as_spaces} or with the \code{tabs.as.spaces} parameter.

We chose to interpret ANSI CSI SGR sequences because this reduces how
much string transcription we need to do during string manipulation.  If we do
not interpret the sequences then we need to record all of them from the
beginning of the string and prepend all the accumulated tags up to beginning
of a substring to the substring.  In many case the bulk of those accumulated
tags will be irrelevant as their effects will have been superseded by
subsequent tags.

\code{fansi} assumes that ANSI CSI SGR sequences should be interpreted in
cumulative "Graphic Rendition Combination Mode".  This means new SGR
sequences add to rather than replace previous ones, although in some cases
the effect is the same as replacement (e.g. if you have a color active and
pick another one).
}

\section{Encodings / UTF-8}{


\code{fansi} will convert any non-ASCII strings to UTF-8.  These strings are
interpreted in a manner intended to be consistent with base R.  There are
three ways things may not work out exactly as desired:
\enumerate{
\item \code{fansi} fails to treat a UTF-8 sequence the same way as R does
\item R incorrectly treats a UTF-8 sequences
\item Your display incorrectly handles a UTF-8 sequences
}

These issues are most likely to occur with invalid UTF-8 sequences, with
combining character sequences, and emoji.  For example, as of this writing R
(and the OSX terminal) consider emojis to be one wide characters, when in
reality they are two wide.  Do not expect the \code{fansi} width
calculations to to work correctly with strings containing emoji.

Internally, \code{fansi} computes the width of every UTF-8 character sequence
outside of the ASCII range using the native \code{R_nchar} function.  This will
cause such characters to be processed slower than ASCII characters.
Additionally, \code{fansi} character width computations can differ from R width
computations because \code{fansi} always computes width for each character, and it
is theoretically possible for \code{R_nchar} to return a width for a
character sequence that forms a single grapheme that is different than the
sum of the character widths.  In informal testing we have found this to be
rare because in the most common multi-character graphemes the combining
characters are computed as zero width.

Ultimately we would like to adopt a proper UTF-8 library like

\href{https://github.com/patperry/r-utf8/}{r-utf8} or
\href{https://github.com/patperry/utf8lite}{utf8lite}, but that probably won't
happen for a while.
}

