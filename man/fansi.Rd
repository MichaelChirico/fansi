% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fansi-package.R
\docType{package}
\name{fansi}
\alias{fansi}
\title{Details About Manipulation of Strings Containing Control Sequences}
\description{
Counterparts to R string manipulation functions that account for
the effects of some ANSI X3.64 (a.k.a. ECMA-48, ISO-6429) control sequences.
}
\section{Control Characters and Sequences}{


Control characters and sequences are non-printing inline characters that can
be used to modify terminal display and behavior, for example by changing text
color or cursor position.

We will refer to X3.64/ECMA-48/ISO-6429 control characters and sequences as
"\emph{Control Sequences}" hereafter.

There are four types of \emph{Control Sequences} that \code{fansi} can treat
specially:
\itemize{
\item "C0" control characters, such as tabs and carriage returns (we include
delete in this set, even though technically it is not part of it).
\item Sequences starting in "ESC[", also known as Control Sequence
Introducer (CSI) sequences, of which the Select Graphic Rendition (SGR)
sequences used to format terminal output are a subset.
\item Sequences starting in "ESC]", also known as Operating System
Commands (OSC).
\item Sequences starting in "ESC" and followed by something other than "[".
}

\emph{Control Sequences} starting with ESC are assumed to be two characters
long (including the ESC) unless they are of the CSI or OSC variety, in which
case their length is computed as per the \href{https://www.ecma-international.org/publications-and-standards/standards/ecma-48/}{ECMA-48 specification},
with the exception that OSC-encoded URLs may be terminated with BEL ("\\a")
in addition to ST ("ESC\\").

\code{fansi} handles most common \emph{Control Sequences} in its parsing
algorithms, but it is not a conforming implementation of ECMA-48.  For
example, there are non-CSI escape sequences that may be longer than two
characters, but \code{fansi} will (incorrectly) treat them as if they were
two characters long.  There are many more unimplemented ECMA-48
specifications.

In theory it is possible to encode CSI sequenes with a single byte
introducing character in the 0x40-0x5F range instead of the traditional
"ESC[".  Since this is rare and it conflicts with UTF-8 encoding, \code{fansi}
does not support it.

The special treatment of \emph{Control Sequences} is to compute their
display/character width as zero.  For the SGR subset of the CSI sequences and
OSC-encoded URLs,, \code{fansi} will also parse, interpret, and reapply the text
the sequences as needed.  Whether a particular type of \emph{Control Sequence} is
treated specially can be specified via the \code{ctl} parameter to the \code{fansi}
functions that have it.
}

\section{CSI SGR Control Sequences}{


\strong{NOTE}: not all displays support CSI SGR sequences; run
\code{\link{term_cap_test}} to see whether your display supports them.

CSI SGR Control Sequences are the subset of CSI sequences that can be
used to change text appearance (e.g. color).  These sequences begin with
"ESC[" and end in "m".  \code{fansi} interprets these sequences and writes new
ones to the output strings in such a way that the original formatting is
preserved.  In most cases this should be transparent to the user.

Occasionally there may be mismatches between how \code{fansi} and a display
interpret the CSI SGR sequences, which may produce display artifacts.  The
most likely source of artifacts are \emph{Control Sequences} that move
the cursor or change the display, or that \code{fansi} otherwise fails to
interpret, such as:
\itemize{
\item Unknown SGR substrings.
\item "C0" control characters like tabs and carriage returns.
\item Other escape sequences.
}

Another possible source of problems is that different displays parse
and interpret control sequences differently.  The common CSI SGR sequences
that you are likely to encounter in formatted text tend to be treated
consistently, but less common ones are not.  \code{fansi} tries to hew by the
ECMA-48 specification \strong{for CSI control sequences}, but not all terminals
do.

The most likely source of problems will be 24-bit CSI SGR sequences.
For example, a 24-bit color sequence such as "ESC[38;2;31;42;4" is a
single foreground color to a terminal that supports it, or separate
foreground, background, faint, and underline specifications for one that does
not.  To mitigate this particular problem you can tell \code{fansi} what your
terminal capabilities are via the \code{term.cap} parameter or the
"fansi.term.cap" global option, although \code{fansi} does try to detect them by
default.

\code{fansi} will will warn if it encounters \emph{Control Sequences} that it cannot
interpret or that might conflict with terminal capabilities.  You can turn
off warnings via the \code{warn} parameter or via the "fansi.warn" global option.
Any SGR codes that it interprets and re-outputs in substrings will be
compatible with the specified terminal capabilities; however, some parts of
substrings are copied as-is and those will retain the original unsupported
SGR codes.

\code{fansi} can work around "C0" tab control characters by turning them into
spaces first with \code{\link{tabs_as_spaces}} or with the \code{tabs.as.spaces} parameter
available in some of the \code{fansi} functions.

We chose to interpret CSI SGR sequences because this reduces how much string
transcription we need to do during string manipulation.  If we do not
interpret the sequences then we need to record all of them from the beginning
of the string and prepend all the accumulated tags up to beginning of a
substring to the substring.  In many case the bulk of those accumulated tags
will be irrelevant as their effects will have been superseded by subsequent
tags.

\code{fansi} assumes that CSI SGR sequences should be interpreted in cumulative
"Graphic Rendition Combination Mode".  This means new SGR sequences add to
rather than replace previous ones, although in some cases the effect is the
same as replacement (e.g. if you have a color active and pick another one).

While we try to minimize changes across \code{fansi} versions in how SGR sequences
are output, we focus on minimizing the changes to rendered output, not
necessarily the specific SGR sequences used to produce it.  To maximize the
odds of getting stable SGR output use \code{\link{normalize_state}} and set \code{term.cap} to
a specific set of capabilities.  In general it is likely best not to rely on
the exact SGR encoding of \code{fansi} output.

Note that \code{width} calculations may also change across R versions, locales,
etc. (see "Encodings / UTF-8" below).
}

\section{OSC Encoded URLs}{


Operating System Commands are interpreted by terminal emulators typically to
engage actions external to the display of text proper, such as setting a
window title or changing the active color palette.

\link[=1]{Some terminals} have added support for associating URLs to text with OSCs
in a similar way to anchors in HTML, so \code{fansi} interprets them and outputs
or terminates them as needed.
}

\section{State Interactions}{


The cumulative nature of state as specified by SGR or OSC-encoded URLs means
that SGR in strings that are spliced will interact with each other.
Additionally, a substring does not inherently contain all the information
required to recreate its state as it appeared in the source string.

One form of interaction to consider is how a character vector provided to
\code{fansi} functions affect itself.  By default, \code{fansi} assumes that each
element in an input character vector is independent, but this is incorrect if
the input is a single document with each element a line in it.  In that
situation state from each line should bleed into subsequent ones.  Setting
\code{carry = TRUE} enables the "single document" interpretation.  \code{\link{sgr_to_html}}
is the exception as for legacy reasons it defaults to \code{carry = TRUE}.

Another form of interaction is when substrings produced by \code{fansi} are
spliced with or into other substrings.  By default \code{fansi} automatically
terminates substrings it produces if they contain active formats or URLs.
This prevents the state to bleed into external strings, which is useful e.g.
when arranging text in columns.  We can allow the state to bleed into
appended strings by setting \code{terminate = FALSE}.  \code{carry} is unaffected by
\code{terminate} as \code{fansi} records the ending SGR state prior to termination
internally.

Finally, \code{fansi} strings will be affected by any active state in strings they
are appended to.  There are no parameters to control what happens
automatically in this case, but \code{fansi} provides several functions that can
help the user get their desired outcome.  \code{state_at_end} computes the active
state the end of a string, this can then be prepended onto the \emph{input} of
\code{fansi} functions so that they are aware of the active style at the beginning
of the string.  Alternatively, one could use \code{close_state(state_at_end(...))}
and pre-pend that to the \emph{output} of \code{fansi} functions so they are unaffected
by preceding SGR.  One could also just prepend "ESC[0m", but in some cases as
described in \code{\link[=normalize_state]{?normalize_state}} that is sub-optimal.
}

\section{Encodings / UTF-8}{


\code{fansi} will convert any non-ASCII strings to UTF-8 before processing them,
and \code{fansi} functions that return strings will return them encoded in UTF-8.
In some cases this will be different to what base R does.  For example,
\code{substr} re-encodes substrings to their original encoding.

Interpretation of UTF-8 strings is intended to be consistent with base R.
There are three ways things may not work out exactly as desired:
\enumerate{
\item \code{fansi}, despite its best intentions, handles a UTF-8 sequence differently
to the way R does.
\item R incorrectly handles a UTF-8 sequence.
\item Your display incorrectly handles a UTF-8 sequence.
}

These issues are most likely to occur with invalid UTF-8 sequences,
combining character sequences, and emoji.  For example, whether special
characters such as emoji are considered one or two wide evolves as software
implements newer versions the Unicode databases.  Do not expect the \code{fansi}
width calculations to always work correctly with strings containing emoji.

Internally, \code{fansi} computes the width of most UTF-8 character sequences
outside of the ASCII range using the native \code{R_nchar} function.  This will
cause such characters to be processed slower than ASCII characters.  \code{fansi}
also attempts to approximate the effect of emoji combining sequences on
string widths, which R does not at least as of R 4.1.  The
\href{https://cran.r-project.org/package=utf8}{\code{utf8}} package provides a
conforming grapheme parsing implementation.

Because \code{fansi} implements it's own internal UTF-8 parsing it is possible
that you will see results different from those that R produces even on
strings without \emph{Control Sequences}.
}

\section{Overflow}{


The maximum length of input character vector elements allowed by \code{fansi} is
the 32 bit INT_MAX, excluding the terminating NULL.  As of R4.1 this is the
limit for R character vector elements generally, but is enforced at the C
level by \code{fansi} nonetheless.

It is possible that during processing strings that are shorter than INT_MAX
would become longer than that. \code{fansi} checks for that overflow and will
stop with an error if that happens.  A work-around for this situation is to
break up large strings into smaller ones.  The limit is on each element of a
character vector, not on the vector as a whole.  \code{fansi} will also error on
your system if \code{R_len_t}, the R type used to measure string lengths, is less
than the processed length of the string.
}

\section{R < 3.2.2 support}{


Nominally you can build and run this package in R versions between 3.1.0 and
3.2.1.  Things should mostly work, but please be aware we do not run the test
suite under versions of R less than 3.2.2.  One key degraded capability is
width computation of wide-display characters.  Under R < 3.2.2 \code{fansi} will
assume every character is 1 display width.  Additionally, \code{fansi} may not
always report malformed UTF-8 sequences as it usually does.  One
exception to this is \code{\link{nchar_ctl}} as that is just a thin wrapper around
\code{\link[base:nchar]{base::nchar}}.
}

